<?xml version="1.0" encoding="UTF-8"?>
<workflow name="GATE-Lab" version="0.2.7" author="Sorina Camarasu-Pop">

  <description>This application runs GATE on the European Grid Infrastructure. The documentation entry point is available &lt;a href="http://www.opengatecollaboration.org/gatelab"&gt;here&lt;/a&gt;.</description>

  <interface>
    <source name="CPUestimation" type="integer">
      <source-comment>&lt;b&gt;&lt;font color="blue"&gt;CPU estimation&lt;/font&gt;&lt;/b&gt;: an estimation of the total running time of your simulation on a single machine. This parameter is used to determine the number of jobs into which your simulation will be split.
      </source-comment>
    </source>
    <source name="GateInput" type="string">
      <source-comment>&lt;b&gt;&lt;font color="blue"&gt;Gate input&lt;/font&gt;&lt;/b&gt;: a zip file produced by the GATE-Lab containing all your simulation input files.
      </source-comment>
    </source>
    <source name="GateRelease" type="string">
      <source-comment>&lt;b&gt;&lt;font color="blue"&gt;Gate release&lt;/font&gt;&lt;/b&gt;: the release of the GATE simulator that will be used to run your simulation. Contact the admins if you're looking for a release which is not available.
      </source-comment>
    </source>
    <source name="NumberOfParticles" type="string">
      <source-comment>&lt;b&gt;&lt;font color="blue"&gt;Number of particles&lt;/font&gt;&lt;/b&gt;: the number of events found in your macro file.
      </source-comment>
    </source>
    <source name="ParallelizationType" type="string">
      <source-comment>&lt;b&gt;&lt;font color="blue"&gt;Parallelization type&lt;/font&gt;&lt;/b&gt;: using dynamic mode is faster but it can compromise the validity of your simulation. Read the &lt;a href="http://www.opengatecollaboration.org/gatelab"&gt;documentation&lt;/a&gt; to determine if you can use it.
      </source-comment>
    </source>
    <constant name="dummy" type="string" value="toto" cardinality="scalar" />
    <constant name="gateDummy" type="string" value="dummy" cardinality="scalar" />
    <sink name="merged_result" type="string" />
  </interface>

  <processors>
    <processor name="getTasks" >
      <in name="time_estimation" type="integer" depth="0" />
      <in name="type" type="string" depth="0" />
      <out name="stopOnScriptSleepTime" type="integer" depth="0" />
      <out name="nTasks" type="integer" depth="0" />
      <out name="timer_timeout" type="integer" depth="0" />
      <out name="timeout" type="integer" depth="0" />
      <iterationstrategy>
        <cross>
          <port name="time_estimation" />
          <port name="type" />
        </cross>
      </iterationstrategy>
      <beanshell>stopOnScriptSleepTime = 2;
nTasks = 1;
timeout = 1000000;

switch (time_estimation) {
case 1 :
        nTasks = 5;
        stopOnScriptSleepTime = 30;
        timer_timeout = 180;
        break;

case 2 :
        nTasks = 25;
        stopOnScriptSleepTime = 60;
        timer_timeout = 300;
        break;

case 3 :
        nTasks = 100;
        stopOnScriptSleepTime = 300;
        timer_timeout = 900;
        break;

case 4 :
        nTasks = 500;
        stopOnScriptSleepTime = 600;
        timer_timeout = 1200;
        break;



default :
        System.out.println("[getTasks] Error : Wrong value of time estimation");
        break;
}

if (!(type.equals("dyn")) &amp;&amp; !(type.equals("stat")))
{
        System.out.println("[getTasks] Error : Wrong type of simulation");
}
      </beanshell>
    </processor>
    <processor name="generateTasks" >
      <in name="nlines" type="integer" depth="0" />
      <out name="array" type="string" depth="1" />
      <beanshell>System.out.println("[generateTasks] Starting getSeed ");
array = new ArrayList();
for (int i =0; i&lt;nlines;i++)
        array.add(""+i);
      </beanshell>
    </processor>
    <processor name="gate" >
      <in name="input3" type="integer" depth="0" />
      <in name="input2" type="string" depth="0" />
      <in name="input5" type="integer" depth="0" />
      <in name="input4" type="string" depth="0" />
      <in name="input7" type="string" depth="0" />
      <in name="input6" type="string" depth="0" />
      <in name="input1" type="string" depth="0" />
      <in name="input0" type="string" depth="0" />
      <iterationstrategy>
        <cross>
          <port name="input0" />
          <port name="input1" />
          <port name="input2" />
          <port name="input3" />
          <port name="input4" />
          <port name="input5" />
          <port name="input6" />
          <port name="input7" />
        </cross>
      </iterationstrategy>
      <gasw descriptor="[GASW_DIR]/gate.xml"/>
    </processor>
    <processor name="merge" >
      <in name="input2" type="string" depth="0" />
      <in name="input1" type="string" depth="0" />
      <in name="input0" type="string" depth="0" />
      <out name="result0" type="string" depth="0" />
      <iterationstrategy>
        <cross>
          <port name="input0" />
          <port name="input1" />
          <port name="input2" />
        </cross>
      </iterationstrategy>
      <gasw descriptor="[GASW_DIR]/merge.xml"/>
    </processor>
    <processor name="getOutputDir" >
      <in name="input_tgz_lfn" type="string" depth="0" />
      <out name="output_lfn" type="string" depth="0" />
      <beanshell>import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Date;

DateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd_HHmmss");

int lastSlash = input_tgz_lfn.lastIndexOf('/');
String initResDir =  input_tgz_lfn.substring(0,lastSlash);
lastSlash = initResDir.lastIndexOf('/');
output_lfn =  initResDir.substring(0,lastSlash).concat("/outputs/").concat(dateFormat.format(System.currentTimeMillis()));
      </beanshell>
    </processor>
    <processor name="status_init" >
      <beanshell>import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.sql.Statement;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.Timestamp;
import java.util.Date;

/*
private final String DRIVER = "org.apache.derby.jdbc.ClientDriver";
private final String DBURL = "jdbc:derby://data-manager.grid.creatis.insa-lyon.fr:9012/";
*/

private final String DRIVER = "org.h2.Driver";
private final String DBURL = "jdbc:h2:tcp://data-manager.grid.creatis.insa-lyon.fr:9092/";

private Connection connexion;

protected void connectDB()
{
                try
                {
                                Class.forName(DRIVER);
                                //connexion = DriverManager.getConnection(DBURL+ new File("").getAbsolutePath()+"/jobs.db;create=true");
				connexion = DriverManager.getConnection(DBURL+ new File("").getAbsolutePath()+"/db/jobs;create=true;MVCC=TRUE", "gasw", "gasw");
                                connexion.setAutoCommit(true);
                 } catch (SQLException ex) { ex.printStackTrace(); }
        catch (ClassNotFoundException ex) {  ex.printStackTrace();}
}

protected void closeDB()
{
        try {  connexion.close(); } catch (SQLException ex) {  ex.printStackTrace();   }
}

protected void create_minorstatus_table()
{
        try
                {
                    Statement stat = connexion.createStatement();
                    stat.executeUpdate("CREATE TABLE minorstatus ("
                            + "date TIMESTAMP, "
                            + "minorstatus VARCHAR(255)) ");
           System.out.println("[Simulation monitor] minorstatus table created");


         } catch (SQLException ex) {   ex.printStackTrace();  }

}

public synchronized void insert_minorstatus(Timestamp currenttime, String minorstatus)
{
        try {
                        PreparedStatement ps = connexion.prepareStatement("INSERT INTO minorstatus(date, minorstatus)"
                                +" VALUES ('"+currenttime+"','"+minorstatus+"')");
                        ps.execute();

                   } catch (SQLException ex) { System.out.println("[Simulation monitor] Error"+ex.getMessage()); }
}


protected void show_minorstatus()
{
        ResultSet rs;
                try
                {
                        Statement stat = connexion.createStatement();
                        rs = stat.executeQuery("SELECT * FROM minorstatus ");
                        System.out.println("[Simulation monitor]  Displaying Minor status Table");
                        while(rs.next())
                        {
                                      Timestamp timestamp =rs.getTimestamp("date");
                                      String minorstatus = rs.getString("minorstatus");
                                      System.out.println("[Simulation monitor]    ["+timestamp+ "] ---------&gt;    "  +minorstatus+"    **");

                        }
                     System.out.println("*****************************");
                      }catch(Exception e){ System.out.println("[Simulation monitor] Select Error 3:"+e); }
}

connectDB();
create_minorstatus_table();
Timestamp timeStampDate = new Timestamp( new Date().getTime());
insert_minorstatus(timeStampDate,"Launching simulation");
show_minorstatus();
closeDB();

try{
            FileWriter fw = new FileWriter("simustatus.txt");
            fw.write("Launching simulation");
            fw.close();
        }
        catch(Exception e){
            e.printStackTrace();
        }
      </beanshell>
    </processor>
    <processor name="status_inProgress" >
      <beanshell>import java.sql.Timestamp;
import java.util.Date;


connectDB();
Timestamp timeStampDate = new Timestamp( new Date().getTime());
insert_minorstatus(timeStampDate,"Simulation in progress");
show_minorstatus();
closeDB();
try{
            FileWriter fw = new FileWriter("simustatus.txt");
            fw.write("Simulation in progress");
            fw.close();
        }
        catch(Exception e){
            e.printStackTrace();
        }
      </beanshell>
    </processor>
    <processor name="status_merging" >
      <beanshell>import java.sql.Timestamp;
import java.util.Date;


connectDB();
Timestamp timeStampDate = new Timestamp( new Date().getTime());
insert_minorstatus(timeStampDate,"Merging results");
show_minorstatus();
closeDB();

try{
            FileWriter fw = new FileWriter("simustatus.txt");
            fw.write("Merging results");
            fw.close();
        }
        catch(Exception e){
            e.printStackTrace();
        }
      </beanshell>
    </processor>
    <processor name="status_merged" >
      <beanshell>try{
            FileWriter fw = new FileWriter("simustatus.txt");
            fw.write("No more active merging job. Please validate or retry merge process (will expire in 3 days)");
            fw.close();
        }
        catch(Exception e){
            e.printStackTrace();
        }
      </beanshell>
    </processor>
    <processor name="setTimeout" >
      <in name="timeout" type="integer" depth="0" />
      <beanshell>String name = "[set timeout] ";
        String dirname = "conf";
        File dir = new File(dirname);
        String[] files = dir.list();
        if (files == null){
            System.err.println("[Simulation monitor] "+ name+"no configuration file found !");
            return;
        }
        for(int i = 0 ; i&lt; files.length ; i++){
            String filename = dirname+"/"+files[i];
            File conf = new File(filename);
            BufferedReader br = null;
            try{
                FileWriter newConf = new FileWriter(filename+"-new");
                br = new BufferedReader(new FileReader(new File(filename)));
                String s = "";
                String r = "";
                while((s=br.readLine())!=null){
                    if(s.startsWith("TIMEOUT=")){
                        //write new timeout
                        r="TIMEOUT="+timeout+"\n";
                    }
                    else
                        {
                            //just copy the line
                            r=s+"\n";
                        }

                    newConf.write(r);
                }
                newConf.close();
                br = new BufferedReader(new FileReader(new File(filename+"-new")));
                newConf = new FileWriter(filename);
                while((s=br.readLine())!=null){
                    newConf.write(s+"\n");
                }
                newConf.close();
                File ff = new File(filename+"-new");
                ff.delete();
            }
            catch(Exception e){
                System.err.println("[Simulation monitor] "+name+e.getMessage());
            }
        }
      </beanshell>
    </processor>
    <processor name="simulationMonitor" >
      <in name="simuType" type="string" depth="0" />
      <in name="StopOnScriptSleepTime" type="integer" depth="0" />
      <in name="nTasks" type="integer" depth="0" />
      <in name="timer_timeout" type="integer" depth="0" />
      <in name="TotalNbParticle" type="string" depth="0" />
      <iterationstrategy>
        <cross>
          <port name="nTasks" />
          <port name="TotalNbParticle" />
          <port name="timer_timeout" />
          <port name="simuType" />
          <port name="StopOnScriptSleepTime" />
        </cross>
      </iterationstrategy>
      <beanshell>import java.io.*;
import java.net.Socket;
import java.net.UnknownHostException;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.Date;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.sql.Statement;
import java.sql.PreparedStatement;
import java.sql.ResultSet;




    static final int port = 50008;
    //static final String host="kingkong.grid.creatis.insa-lyon.fr";
    static final String host="data-manager.grid.creatis.insa-lyon.fr";
    //private final String DRIVER = "org.apache.derby.jdbc.ClientDriver";
    //private final String DBURL = "jdbc:derby://ui.egee.creatis.insa-lyon.fr:9012/";
    private Connection connection;
	private boolean isConnected = false;
    private final int index = new File("").getAbsolutePath().lastIndexOf("/");
    private final String workflowid = new File("").getAbsolutePath().substring(index+1);
    static final long totalparticles = new Long(TotalNbParticle);


        // connexion to the DB
        protected void connect()
        {
			while(!isConnected){
                     try
                    {
                                Class.forName(DRIVER);
                                //connection = DriverManager.getConnection(DBURL+ new File("").getAbsolutePath()+"/jobs.db;create=true");
				connection = DriverManager.getConnection(DBURL+ new File("").getAbsolutePath()+"/db/jobs;create=true;MVCC=TRUE", "gasw", "gasw");
                                connection.setAutoCommit(true);
								isConnected = true;
                     } catch (SQLException ex) { 
						System.err.println("[Simulation monitor] Connection problem with the DB: sleeping 1 minute and attempting to reconnect.");
						Thread.currentThread().sleep(60000);
						ex.printStackTrace();
						}
						
			}
        }

        //close DB connexion
        protected void close()
        {
                        try {  connection.close(); } catch (SQLException ex) {  ex.printStackTrace();   }
        }

        // Create particles and somme tables
        protected void createTables()
        {
               try
                {
					if(!isConnected){
						connect();
					}
				    System.out.println("[Simulation monitor] "+DBURL);
                    Statement stat = connection.createStatement();
                    stat.executeUpdate("CREATE TABLE somme ("
                            + "somme BIGINT, "
                            + "simulation VARCHAR(255)) ");

                    System.out.println("[Simulation monitor] Sum table created.");

               } catch (SQLException ex) {   
			   		isConnected = false;
					ex.printStackTrace();  
				
				}

               try
              {
					if(!isConnected){
						connect();
					}
                    System.out.println("[Simulation monitor] "+DBURL);
                    Statement stat = connection.createStatement();
                    stat.executeUpdate("CREATE TABLE particles ("
                            + "jobid VARCHAR(255), "
                            + "particles BIGINT, "
                            + "PRIMARY KEY (jobid)"
                            + ")");
                    System.out.println("[Simulation monitor] Particle table created.");
              } catch (SQLException ex) { 
				isConnected = false;
				ex.printStackTrace(); 
			  }

        }

        // insert particles into DB
        public synchronized void add(String idjob, long npart)
        {
             try {
						if(!isConnected){
							connect();
						}
                        PreparedStatement ps = connection.prepareStatement("INSERT INTO particles "
                                + "(jobid , particles) " + "VALUES ('"+idjob+"',"+npart+")");
                        ps.execute();
                      } catch (SQLException ex) { 
						isConnected = false;
						System.out.println("[Simulation monitor] Erreur add "+ex.getMessage()); 
					  }
        }

        // update particles tables: update the particles simulated by idjob
        public synchronized void update(String idjob, long npart)
        {
              try{
						if(!isConnected){
							connect();
						}
                        PreparedStatement ps = connection.prepareStatement("UPDATE particles SET "+ "particles ="+npart+" WHERE jobid ='"+idjob+"'");
                        ps.execute();
                      } catch (SQLException ex){  
						isConnected = false;
						System.out.println("[Simulation monitor] Erreur update "+ex.getMessage()); 
					  }
        }

        // find the idjob in the DB particles: return true if existe, false if not
        String find(String id)
        {
              ResultSet rs;
              String trv="false";
              try
              {
					if(!isConnected){
						connect();
					}
					Statement stat = connection.createStatement();
                        rs = stat.executeQuery("SELECT * FROM particles WHERE jobid='"+id+"'");
                        if (rs.next()) trv = "true";
                        else trv = "false";

              }catch(Exception e){ 
			   isConnected = false;
			   System.out.println("[Simulation monitor] Select Error 1: "+e); 
			  }
              return trv;
        }

        // sum of all particles simulated by all the jobs that status are either completed or running
        long sum() throws SQLException
        {
                ResultSet rs;
           try{
				if(!isConnected){
					connect();
				}
                        Statement stat = connection.createStatement();
                        rs = stat.executeQuery("SELECT SUM(particles) as npart FROM particles,jobs"
                                +" WHERE particles.jobid=jobs.id and "
                                +"(jobs.status='COMPLETED' or jobs.status='RUNNING')");
                        rs.next();
                        return rs.getLong("npart");
           }catch(Exception e){ 
		   isConnected = false;
		   System.out.println("[Simulation monitor] Select Error 2:"+e); 
		   return (0L); 
		   }

        }

        // cancel jobs: used to cancel jobs queued or sucessful submitted when stopandmerge or  merge are true
        protected void cancel_jobs()
        {
                ResultSet rs;
                try
                {
					if(!isConnected){
						connect();
					}
                        Statement stat = connection.createStatement();
                        rs = stat.executeQuery("SELECT id FROM jobs WHERE jobs.status!='COMPLETED' and jobs.status!='RUNNING' and jobs.status!='ERROR' ");
                        while(rs.next())
                        {
                                String jobid = rs.getString("id");
                                String cmd = "dirac-wms-job-kill "+jobid;
                                System.out.println("[Simulation monitor] Killing the jobs"+ cmd);
                                Process proc = Runtime.getRuntime().exec(cmd);
                                proc.waitFor();
                        }
                      }catch(Exception e){ 
					  isConnected = false;
					  System.out.println("[Simulation monitor] Select Error killing the jobs:"+e); 
					  }
        }

        // cancel jobs running: used when the timeout is reached to kill running jobs and to not wait for them
        protected void kill_not_completed_jobs()
        {
                ResultSet rs;
                try
                {
					if(!isConnected){
						connect();
					}
                        Statement stat = connection.createStatement();
                rs = stat.executeQuery("SELECT id FROM jobs WHERE jobs.status!='COMPLETED' and jobs.status!= 'CANCELLED' and jobs.status!='ERROR'");
                        while(rs.next())
                        {
                                String jobid = rs.getString("id");
                                String cmd = "dirac-wms-job-kill "+jobid;
                                System.out.println("[Simulation monitor] Killing running jobs "+ cmd);
                                Process proc = Runtime.getRuntime().exec(cmd);
                                proc.waitFor();
                        }
                      }catch(Exception e){ 
					  isConnected = false;
					  System.out.println("[Simulation monitor] Error killing running jobs:"+e); 
					  }
        }


        // return nb of "status" jobs
        int nb_jobs(String status)
        {
                int nbjobs = 0;
                ResultSet rs;
                     try
                    {
						if(!isConnected){
							connect();
						}
                        Statement stat = connection.createStatement();
                        rs = stat.executeQuery("SELECT count(*) as nbjobs FROM jobs WHERE status='"+status+"' ");
                        while(rs.next())
                        {
                                      nbjobs= rs.getInt("nbjobs");
                                      System.out.println("[Simulation monitor]    NB JOBS "+status+" is" +nbjobs+"    **");
                        }
                      }catch(Exception e){ 
					  isConnected = false;
					  System.out.println("[Simulation monitor] Select Error nb jobs"+status+" :"+e); 
					  }
                return nbjobs;
        }

        // display the result
        protected void show_result()
        {
                ResultSet rs;
                     try
                    {
						if(!isConnected){
							connect();
						}
                        Statement stat = connection.createStatement();
                        rs = stat.executeQuery("SELECT * FROM particles ");
                        System.out.println("[Simulation monitor]  JobID   **  Particles  **");
                        while(rs.next())
                        {
                                      String jobid = rs.getString("jobid");
                                      long nparticle = rs.getLong("particles");
                                      System.out.println("[Simulation monitor]    "+jobid+ "  **    "  +nparticle+"    **");
                                      //System.out.println("Numbres of particles of job ="+jobid+" is: "+nparticle);
                     }
//                   System.out.println("*****************************");
                      }catch(Exception e){ 
					  isConnected = false;
					  System.out.println("[Simulation monitor] Select Error 3:"+e); 
					  }
        }

        // check the stop and merge variable in the DB
        String stopandmerge()
        {
                ResultSet rs;
                    try
                   {
						if(!isConnected){
							connect();
						}
                        Statement stat = connection.createStatement();
                        rs = stat.executeQuery("SELECT simulation FROM somme ");
                        rs.next();
                        String  trv = rs.getString(1);
                        if (trv.compareTo("true")==0)
                                        return "true";
                        else
                                        return "false";


                   }catch(Exception e){ 
				   isConnected = false;
				   System.out.println("[Simulation monitor] Select Error 4:"+e); 
				   return "false";
				   }

        }

        public synchronized void insert(long sum, String check)
        {
                   try {
				   	    if(!isConnected){
							connect();
						}
                        PreparedStatement ps = connection.prepareStatement("INSERT INTO somme(somme,simulation)"
                                +" VALUES ("+sum+",'"+check+"')");
                        ps.execute();

                   } catch (SQLException ex) { 
				   isConnected = false;
				   System.out.println("[Simulation monitor] Error"+ex.getMessage()); 
				   }
        }


        //  update sum of the total particles simulated
        public synchronized void updatesum()
        {
                    try
                   {
						if(!isConnected){
							connect();
						}
                        long nb= sum();
                        PreparedStatement ps = connection.prepareStatement("UPDATE somme SET "+ "somme = "+nb+" WHERE somme != "+nb );
                        ps.execute();
                    } catch (SQLException ex){ 
					isConnected = false;
					System.out.println("[Simulation monitor] Error "+ex.getMessage()); 
					}
        }


        //send end connexion to dirac server
        public synchronized void sendtodirac(String messag)
        {
                try
                {
                // Send STOP signal to the dirac server
                Socket sockt = new Socket(host, port);
                PrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(sockt.getOutputStream())), true);
                if (messag.equals("stop"))  System.out.println("[Simulation monitor] sending STOP");
                else System.out.println("[Simulation monitor] simulationMonitor finished. Closing the connection.");
                out.println(messag);
                out.println(workflowid);
                sockt.close();

                } catch (UnknownHostException ex) { System.out.println("[Simulation monitor] Error"+ex.getMessage());}
                  catch (IOException ex) {  System.out.println("[Simulation monitor] Error"+ex.getMessage()); }
        }


//out = in ;
connect();
createTables();
System.out.println("[Simulation monitor] Job number: "+nTasks);
System.out.println("[Simulation monitor] Initial number of particles: "+ totalparticles );
boolean stopandmerge = false;
boolean merge = false;
boolean alljobscompleted = false;
boolean timeout_reached = false;

// Timer started after stopandmerge or merge
Thread timerth =  new Thread()
{
        public void run()
        {
                long   start_timeout=System.nanoTime();
                long currenttime= System.nanoTime();
                long timeout =  timer_timeout*1000000000L;
                long timedif;
                while( (timedif=currenttime - start_timeout)  &lt; timeout   &amp;&amp;  !timeout_reached )
                {
                    try
                   {
                        sleep(10000);
                   } catch (InterruptedException ex) { System.out.println("[Simulation monitor] Error"+ex.getMessage());  }
                        currenttime= System.nanoTime();
                }
                System.out.println("[Simulation monitor] end of the timeout----"+ start_timeout+"----"+currenttime);
                timeout_reached=true;
        }
};

// Thread sp�cifique au mise � jour de la somme des particules et de l'arr�t de la simulation (merge ou stop and merge)
Thread th = new Thread()
{
    long   start_timeout=System.nanoTime();
    long currenttime= System.nanoTime();
    long timeout =  StopOnScriptSleepTime*10*1000000000L;
    long timedif;
    long sum= 0L;
    public void run()
    {

        // Wait for the notification of the first message
        synchronized (this)
        {
                wait();
                System.out.println("[Simulation monitor] Notification received");
        }

        insert(0L, "false");
        //for dynamic simulation exit condition are stopandmerge or particles reached
        if (simuType.equals("dyn"))
        {
                while ((timedif=currenttime - start_timeout)  &lt;  timeout )
                {
                    updatesum();

                    // Fetch the stop and merge value. If true exit the while
                    if (stopandmerge().equals("true"))
                    {
                        System.out.println("[Simulation monitor] "+new Date().toString()+" Sending stop signal to the jobs.");
                        stopandmerge= true;
                        break;
                    }
                    try
                    { sleep(2000);} catch (InterruptedException ex) { System.out.println("[Simulation monitor] Error"+ex.getMessage());}


                    if (sum != sum() )
                    {
                        start_timeout=System.nanoTime();
                        sum=sum();
                    }
                    //if numbre of particle simulated reach total partilces exit the while
                    if ( sum() &gt;= totalparticles  )
                    {
                        System.out.println("[Simulation monitor] Initial number of particles reached --&gt;"+ sum()) ;
                        merge = true;
                        break;
                    }

                    currenttime= System.nanoTime();
                }
                if ((timedif=currenttime - start_timeout)  &gt; timeout)
                {
                        System.out.println("[Simulation monitor] Timeout of message from jobs reached ---&gt; starting merge ");
                        merge= true;
                }
        }else{ //for static simulation exit condition are stopandmerge or all jobs completed

                while(true)
                {
                    updatesum();

                    // Fetch the stop and merge value. If true exit the while
                    if (stopandmerge().equals("true"))
                    {
                        System.out.println("[Simulation monitor] "+new Date().toString()+" Stop and merge----envoi stop");
                        stopandmerge= true;
			//kill all running jobs because uncomplete results in static simulations can be false
			kill_not_completed_jobs();
                        break;
                    }
                    try
                    {   sleep(2000);} catch (InterruptedException ex) { System.out.println("[Simulation monitor] Error"+ex.getMessage());}

                    //if numbre of particle simulated reach total partilces exit the while
                    if ( nb_jobs("COMPLETED") ==  nTasks )
                    {
                        System.out.println("[Simulation monitor]------------------***** All jobs finished their executions **********---------") ;
                        merge = true;
                        break;
                    }
                }
        }

        updatesum();

        if (sum() &gt;=  totalparticles )
        {
                System.out.println("[Simulation monitor] Reached total number of particles");
        }

        //sending stop simulation to jobs
        sendtodirac("stop");

        // Cancel all jobs NOT {COMPLETED, RUNNING}
        cancel_jobs();
    }
};


// Thread for receiving particles from dirac seveur (from jobs)
Thread t = new Thread()
{
        long  nbpart = 0L;
        String idjob = null;
        String msg=null;

        public void run()
        {
                // initiate connexion with the dirac server
                boolean reconnect = true;

                Socket sock;
                PrintWriter os;
                BufferedReader is;


                while (!timeout_reached)
                {
                    try
                    {
                        if(reconnect){
                             System.out.println("[Simulation monitor] Connecting to particle counting service ("+host+":"+port+")");
                             reconnect = false;
                             sock = new Socket(host, port);
                             os = new PrintWriter(new BufferedWriter(new OutputStreamWriter(sock.getOutputStream())), true);
                             is = new BufferedReader(new InputStreamReader(sock.getInputStream()));
                             os.println(workflowid);
                        }
                        // treatment of the all the messages received from the dirac server
                        if((msg = is.readLine())!= null)
                        {
                            List list = Arrays.asList(msg.split(",")) ;
                            if (list.get(0).toString().compareTo("connexion established")==0)
                            {
                                System.out.println("[Simulation monitor] Received message " + msg);
                            }
                            else if (list.get(0).toString().compareTo("finalmsg")==0)
                            {
                                idjob = list.get(1).toString();
                                nbpart = new Long(list.get(2).toString());
                                if (find(idjob).compareTo("false")==0)
                                {
                                        add(idjob,nbpart);
                                }
                                else
                                {
                                    update(idjob, nbpart);
                                }
                                updatesum();
                            }
                            else
                            {
                                idjob = list.get(0).toString();
                                nbpart = new Long(list.get(1).toString());
                                synchronized (th){  th.notify() ; }
                                if (find(idjob).compareTo("false")==0)
                                {
                                        add(idjob,nbpart);
                                }
                                else
                                {
                                    update(idjob, nbpart);
                                }
                                updatesum();
                            }
                        }
                    }catch (IOException ex)
                    {
                        int sleepTime = 60000;
                        System.err.println("[Simulation monitor] Connection problem with the counting service: sleeping 1 minute and attempting to reconnect.");
                        Thread.currentThread().sleep(sleepTime);
                        reconnect = true;
                    }
                }
        updatesum();
        System.out.println("[Simulation monitor] Stopping simulation");
        System.out.println("[Simulation monitor] Total of particule executed is "+ sum());

        // close dirac server connexion
        sock.close();



        }
};

t.start();
th.start();

while(!stopandmerge &amp;&amp; !merge )
{
        Thread.sleep(2000);

}

timerth.start();

while (!timeout_reached)
{

        //used only in dynamic mode and in static only when pressing stop and merge
        if (nb_jobs("RUNNING")== 0)
        {
                updatesum();
                System.out.println("[Simulation monitor] all running jobs completed  -- "+ timeout_reached);
                alljobscompleted = true;
                timeout_reached = true ;

        }
        Thread.sleep(2000);

}

// kill all jobs NOT {COMPLETED, CANCELLED, ERROR}
if (timeout_reached)
{
        System.out.println("[Simulation monitor] timeout reached");
        kill_not_completed_jobs();
}

// close the DB connexion
//close();
System.out.println("[Simulation monitor] exit simulation monitor");
if (stopandmerge)  System.out.println("[Simulation monitor] -----&gt;&gt;&gt; stop and merging...");
if (merge) System.out.println("[Simulation monitor] -----&gt;&gt;&gt; Merging ");
System.out.println("[Simulation monitor] Particles simulated is  "+ sum());
updatesum();
sendtodirac("endconnexion");
      </beanshell>
    </processor>
  </processors>

  <links>
      <link from="CPUestimation" to="getTasks:time_estimation" />
      <link from="getTasks:nTasks" to="generateTasks:nlines" />
      <link from="GateRelease" to="gate:input0" />
      <link from="GateInput" to="gate:input1" />
      <link from="generateTasks:array" to="gate:input2" />
      <link from="getTasks:stopOnScriptSleepTime" to="gate:input5" />
      <link from="getTasks:nTasks" to="gate:input3" />
      <link from="GateInput" to="getOutputDir:input_tgz_lfn" />
      <link from="getOutputDir:output_lfn" to="merge:input1" />
      <link from="merge:result0" to="merged_result" />
      <link from="ParallelizationType" to="getTasks:type" />
      <link from="ParallelizationType" to="gate:input6" />
      <link from="getTasks:timeout" to="setTimeout:timeout" />
      <link from="getTasks:nTasks" to="simulationMonitor:nTasks" />
      <link from="NumberOfParticles" to="simulationMonitor:TotalNbParticle" />
      <link from="dummy" to="merge:input2" />
      <link from="getTasks:timer_timeout" to="simulationMonitor:timer_timeout" />
      <link from="ParallelizationType" to="simulationMonitor:simuType" />
      <link from="getTasks:stopOnScriptSleepTime" to="simulationMonitor:StopOnScriptSleepTime" />
      <link from="GateInput" to="merge:input0" />
      <link from="getOutputDir:output_lfn" to="gate:input7" />
      <link from="gateDummy" to="gate:input4" />
  </links>

  <coordinations>
      <link from="generateTasks" to="status_inProgress" />
      <link from="simulationMonitor" to="merge" />
      <link from="simulationMonitor" to="status_merging" />
      <link from="merge" to="status_merged" />
      <link from="status_init" to="getTasks" />
  </coordinations>

</workflow>
